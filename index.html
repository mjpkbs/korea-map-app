<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>한국 지도 — Mapbox 대용량 GeoJSON & 런타임 스타일</title>

  <!-- Mapbox GL / Geocoder (CDN) -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/3.3.0/mapbox-gl.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/3.3.0/mapbox-gl.min.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14; --panel:#11161d; --muted:#9fb0c3; --accent:#2eaadc; --border:#1f2a36; --text:#e6eef7;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Pretendard,Apple SD Gothic Neo,Noto Sans KR,Arial,sans-serif}
    #app{display:grid;grid-template-columns:360px 1fr;height:100%}
    #panel{background:var(--panel);border-right:1px solid var(--border);padding:14px 14px 18px;overflow:auto}
    #map{position:relative}
    #mapContainer{width:100%;height:100%}
    h1{font-size:18px;margin:0 0 8px 0}
    h2{font-size:13px;margin:10px 0;color:var(--muted);font-weight:700;letter-spacing:.4px}
    label{display:block;font-size:13px;margin:8px 0 4px}
    input[type="text"], input[type="number"], select{
      width:100%;padding:9px 10px;border:1px solid var(--border);border-radius:10px;background:#0c1218;color:var(--text);outline:none
    }
    input[type="color"]{width:100%;height:38px;border:1px solid var(--border);border-radius:10px;background:#0c1218}
    input[type="range"]{width:100%}
    .row{display:grid;grid-template-columns:1fr 110px;gap:10px;align-items:center}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .btn{background:#13202c;border:1px solid var(--border);color:var(--text);padding:9px 12px;border-radius:10px;cursor:pointer;font-weight:600}
    .btn:hover{background:#0f1a24}
    .ghost{background:transparent}
    .section{background:#0c1218;border:1px solid var(--border);border-radius:14px;padding:12px;margin-bottom:12px}
    .inline{display:flex;gap:10px;align-items:center}
    .switch{display:flex;align-items:center;justify-content:space-between}
    .muted{color:var(--muted);font-size:12px}
    .small{font-size:12px}
    #status{font-size:12px;color:#b8c7d8;line-height:1.5}
    .floating{position:absolute;top:10px;left:10px;z-index:5}
    .toast{position:absolute;top:10px;right:10px;background:rgba(0,0,0,.6);color:#fff;padding:8px 10px;border-radius:8px;z-index:10}
  </style>
</head>
<body>
<div id="app">
  <aside id="panel">
    <h1>한국 지도 앱 — Mapbox</h1>
    <div class="section">
      <label>Mapbox Access Token</label>
      <input id="token" type="text" placeholder="본인 Access Token을 입력하세요" />
      <div class="two" style="margin-top:8px">
        <button class="btn" id="initMap">지도 초기화</button>
        <button class="btn ghost" id="saveToken">토큰 저장</button>
      </div>
      <div class="muted small" style="margin-top:6px">* 토큰은 localStorage에 저장됩니다.</div>
    </div>

    <div class="section">
      <h2>검색</h2>
      <div class="muted small">좌측 상단 검색창(Geocoder)에서 주소/장소 검색 → 자동 줌</div>
    </div>

    <div class="section">
      <h2>행정구역 레벨 (대용량 대응: ON 때만 로드)</h2>
      <div class="switch"><span>시도</span><input type="checkbox" id="chkSido"></div>
      <div class="switch"><span>시군구</span><input type="checkbox" id="chkSigungu"></div>
      <div class="switch"><span>읍면동</span><input type="checkbox" id="chkEmd"></div>
      <div class="muted small" style="margin-top:6px">* 켜면 해당 GeoJSON을 fetch→소스/레이어 추가, 끄면 제거하여 메모리 절약</div>
    </div>

    <div class="section">
      <h2>라벨</h2>
      <div class="switch"><span>Mapbox 기본 라벨</span><input type="checkbox" id="chkBaseLabels" checked></div>
      <div class="switch"><span>행정 라벨(우리 데이터)</span><input type="checkbox" id="chkOurLabels" checked></div>
      <div class="muted small" style="margin-top:6px">* 기본 라벨은 스타일의 심볼 레이어 전체를 휴리스틱으로 제어(스타일에 따라 일부 예외 가능)</div>
    </div>

    <div class="section">
      <h2>런타임 스타일</h2>
      <div class="row">
        <div>
          <label>바다색</label><input type="color" id="waterColor" value="#0f3564">
        </div>
        <div>
          <label class="small">불투명도</label><input type="range" id="waterOpacity" min="0" max="1" step="0.01" value="1">
        </div>
      </div>
      <div class="row">
        <div>
          <label>육지색</label><input type="color" id="landColor" value="#8896a1">
        </div>
        <div>
          <label class="small">불투명도</label><input type="range" id="landOpacity" min="0" max="1" step="0.01" value="1">
        </div>
      </div>
      <div>
        <label>경계선색</label><input type="color" id="boundaryColor" value="#ffffff">
      </div>
      <div class="row">
        <label>나라 경계선 굵기(px)</label><input type="range" id="countryWidth" min="0.5" max="6" step="0.1" value="1.5">
      </div>
      <div class="inline">
        <input type="checkbox" id="countryDashed"><label for="countryDashed">나라 경계선 점선</label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>행정 경계선 굵기(px)</label><input type="range" id="adminWidth" min="0.5" max="6" step="0.1" value="1.0">
      </div>
      <div class="inline">
        <input type="checkbox" id="adminDashed"><label for="adminDashed">행정 경계선 점선</label>
      </div>
    </div>

    <div class="section">
      <h2>선택 영역 색칠</h2>
      <label>선택 색</label><input type="color" id="selectColor" value="#ffcc33">
      <div class="inline" style="margin-top:6px"><input type="checkbox" id="selectHalf" checked><label for="selectHalf">반투명</label></div>
      <div class="two" style="margin-top:8px">
        <button class="btn" id="clearSelection">선택 해제</button>
        <button class="btn ghost" id="exportSelection">GeoJSON 내보내기</button>
      </div>
      <div class="muted small" style="margin-top:6px">* 지도에서 시도/시군구/읍면동 채움 레이어를 클릭해 다중 선택</div>
    </div>

    <div class="section">
      <h2>PNG 저장</h2>
      <button class="btn" id="savePng">현재 화면 PNG로 저장</button>
      <div class="muted small" style="margin-top:6px">* 화면 크기 그대로 저장합니다.</div>
    </div>

    <div class="section">
      <h2>상태</h2>
      <div id="status">준비되지 않음</div>
    </div>
  </aside>

  <main id="map">
    <div id="geocoderMount" class="floating"></div>
    <div id="mapContainer"></div>
    <div id="toast" class="toast" style="display:none"></div>
  </main>
</div>

<script>
(function(){
  // ===== 요소 =====
  const els = {
    token: document.getElementById('token'),
    initMap: document.getElementById('initMap'),
    saveToken: document.getElementById('saveToken'),
    geocoderMount: document.getElementById('geocoderMount'),
    mapContainer: document.getElementById('mapContainer'),
    status: document.getElementById('status'),
    toast: document.getElementById('toast'),
    // toggles
    chkSido: document.getElementById('chkSido'),
    chkSigungu: document.getElementById('chkSigungu'),
    chkEmd: document.getElementById('chkEmd'),
    chkBaseLabels: document.getElementById('chkBaseLabels'),
    chkOurLabels: document.getElementById('chkOurLabels'),
    // style inputs
    waterColor: document.getElementById('waterColor'),
    waterOpacity: document.getElementById('waterOpacity'),
    landColor: document.getElementById('landColor'),
    landOpacity: document.getElementById('landOpacity'),
    boundaryColor: document.getElementById('boundaryColor'),
    countryWidth: document.getElementById('countryWidth'),
    adminWidth: document.getElementById('adminWidth'),
    countryDashed: document.getElementById('countryDashed'),
    adminDashed: document.getElementById('adminDashed'),
    // selection
    selectColor: document.getElementById('selectColor'),
    selectHalf: document.getElementById('selectHalf'),
    clearSelection: document.getElementById('clearSelection'),
    exportSelection: document.getElementById('exportSelection'),
    // export
    savePng: document.getElementById('savePng'),
  };

  // ===== 상태 =====
  const STORE = 'kr-map-index';
  let map = null;
  let detected = null; // { water[], landBg[], landFill[], boundary[], baseLabelIds[] }
  const FILES = { sido:'sido.geojson', sigungu:'sigungu.geojson', emd:'emd.geojson' };
  const FIELDS = { sido:'SIDO_NM', sigungu:'SIGUNGU_NM', emd:'ADM_NM' };
  const selection = new Map(); // key -> feature (선택 GeoJSON 관리)
  let selectionSourceInited = false;

  // ===== 유틸 =====
  function toast(msg){
    els.toast.textContent = msg;
    els.toast.style.display='block';
    setTimeout(()=> els.toast.style.display='none', 2000);
  }
  function setStatus(html){ els.status.innerHTML = html; }
  function saveLocal(){ localStorage.setItem(STORE, JSON.stringify({ token: els.token.value.trim() })); }
  function loadLocal(){
    try { const d = JSON.parse(localStorage.getItem(STORE)||'{}'); if(d.token) els.token.value = d.token; } catch {}
  }
  function download(name, content, mime='application/octet-stream'){
    const blob = new Blob([content], {type:mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download=name; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  // ===== 지도 초기화 =====
  function init(){
    loadLocal();
    els.initMap.addEventListener('click', createMap);
    els.saveToken.addEventListener('click', ()=>{ saveLocal(); toast('토큰 저장됨'); });

    // handlers
    els.chkSido.addEventListener('change', ()=> toggleLevel('sido', els.chkSido.checked));
    els.chkSigungu.addEventListener('change', ()=> toggleLevel('sigungu', els.chkSigungu.checked));
    els.chkEmd.addEventListener('change', ()=> toggleLevel('emd', els.chkEmd.checked));

    els.chkBaseLabels.addEventListener('change', ()=> toggleBaseLabels(els.chkBaseLabels.checked));
    els.chkOurLabels.addEventListener('change', applyOurLabelsVisibility);

    [els.waterColor, els.waterOpacity, els.landColor, els.landOpacity, els.boundaryColor,
     els.countryWidth, els.adminWidth, els.countryDashed, els.adminDashed]
    .forEach(el => el.addEventListener('input', applyRuntimeColors));

    els.selectColor.addEventListener('input', updateSelectionStyle);
    els.selectHalf.addEventListener('change', updateSelectionStyle);
    els.clearSelection.addEventListener('click', clearSelection);
    els.exportSelection.addEventListener('click', exportSelectionGeoJSON);

    els.savePng.addEventListener('click', savePNG);
  }

  function createMap(){
    const token = els.token.value.trim();
    if(!token){ toast('Access Token을 입력하세요'); return; }
    saveLocal();

    mapboxgl.accessToken = token;
    if(map){ map.remove(); map=null; }

    map = new mapboxgl.Map({
      container: 'mapContainer',
      style: 'mapbox://styles/mapbox/standard',
      center: [127.8, 36.3],
      zoom: 6,
      locale: 'ko',
      preserveDrawingBuffer: true
    });

    map.addControl(new mapboxgl.NavigationControl(), 'top-right');

    // Geocoder
    const geocoder = new MapboxGeocoder({
      accessToken: mapboxgl.accessToken,
      mapboxgl: mapboxgl,
      marker: false,
      language: 'ko,en',
      placeholder: '주소 또는 키워드 검색…',
    });
    els.geocoderMount.innerHTML='';
    els.geocoderMount.appendChild(geocoder.onAdd(map));
    geocoder.on('result', e=>{
      if(e.result?.bbox){
        const b=e.result.bbox; map.fitBounds([[b[0],b[1]],[b[2],b[3]]], { padding: 60, duration: 900 });
      }else if(e.result?.center){
        map.flyTo({ center: e.result.center, zoom: 14 });
      }
    });

    map.on('load', ()=>{
      detected = scanStyleLayers();
      setStatus('지도 로드됨 — 레벨을 켜서 GeoJSON을 불러오세요.');
      applyRuntimeColors();
      toggleBaseLabels(els.chkBaseLabels.checked);
      // 초기엔 레벨 off (대용량 대비)
      // 선택 오버레이용 빈 소스 생성
      ensureSelectionSource();
      ensureSelectionLayer();
    });

    map.on('style.load', ()=>{
      // 스타일 재적용
      detected = scanStyleLayers();
      applyRuntimeColors();
      toggleBaseLabels(els.chkBaseLabels.checked);
      applyOurLabelsVisibility();
      // 이미 켠 레벨은 다시 추가
      if(els.chkSido.checked) addLevel('sido');
      if(els.chkSigungu.checked) addLevel('sigungu');
      if(els.chkEmd.checked) addLevel('emd');
      ensureSelectionSource();
      ensureSelectionLayer();
      updateSelectionStyle();
      refreshSelectionFilter();
    });
  }

  // ===== 스타일 레이어 탐색(휴리스틱) =====
  function scanStyleLayers(){
    const found = { water:[], landBg:[], landFill:[], boundary:[], baseLabelIds:[] };
    const layers = (map.getStyle()?.layers)||[];
    layers.forEach(l=>{
      const id = (l.id||'').toLowerCase();
      const srcLayer = (l['source-layer']||'').toLowerCase();
      if(l.type==='background') found.landBg.push(l.id);
      if(/water|ocean|sea/.test(id +' '+ srcLayer)){
        if(['fill','line','background'].includes(l.type)) found.water.push(l.id);
      }
      if(l.type==='fill' && /land|landcover|landuse|earth|natural/.test(id +' '+ srcLayer)){
        found.landFill.push(l.id);
      }
      if(l.type==='line' && /admin|boundary|borders|country/.test(id +' '+ srcLayer)){
        found.boundary.push(l.id);
      }
      if(l.type==='symbol'){
        // 우리 라벨(id에 sido/sigungu/emd-label)이 아닌 심볼은 기본 라벨로 분류
        if(!/(^|-)sido-label|sigungu-label|emd-label/.test(id)) found.baseLabelIds.push(l.id);
      }
    });
    return found;
  }

  function trySet(layerId, prop, val){
    try{ map.setPaintProperty(layerId, prop, val); return true; } catch { return false; }
  }
  function tryLayout(layerId, prop, val){
    try{ map.setLayoutProperty(layerId, prop, val); return true; } catch { return false; }
  }

  // ===== 레벨 토글 (지연 로드/제거) =====
  async function toggleLevel(lvl, on){
    if(!map) return;
    if(on) await addLevel(lvl);
    else removeLevel(lvl);
    applyOurLabelsVisibility();
    applyRuntimeColors();
  }

  async function addLevel(lvl){
    const src = `${lvl}-src`, fill=`${lvl}-fill`, line=`${lvl}-line`, label=`${lvl}-label`;
    if(!map.getSource(src)){
      map.addSource(src, { type:'geojson', data: FILES[lvl], promoteId: FIELDS[lvl] });
    }
    if(!map.getLayer(fill)){
      map.addLayer({ id:fill, type:'fill', source:src, paint:{ 'fill-color':'#ffffff', 'fill-opacity':0.03 } }, firstSymbolId());
    }
    if(!map.getLayer(line)){
      map.addLayer({ id:line, type:'line', source:src, paint:{ 'line-color': els.boundaryColor.value, 'line-width': parseFloat(els.adminWidth.value), 'line-dasharray': els.adminDashed.checked?[2,2]:[1,0] } });
    }
    if(!map.getLayer(label)){
      map.addLayer({ id:label, type:'symbol', source:src,
        layout:{ 'text-field':['get', FIELDS[lvl]], 'text-size':['interpolate',['linear'],['zoom'],6,9,10,12,14,16] },
        paint:{ 'text-color':'#1f2940','text-halo-color':'#fff','text-halo-width':1.2,'text-opacity': els.chkOurLabels.checked?1:0 }
      });
    }
    // 클릭 선택
    bindSelect(fill, lvl);
    setStatus(`로드됨: ${lvl} (필요시 다른 레벨도 켜세요)`);
  }

  function removeLevel(lvl){
    const fill=`${lvl}-fill`, line=`${lvl}-line`, label=`${lvl}-label`, src=`${lvl}-src`;
    [fill,line,label].forEach(id => { if(map.getLayer(id)) map.removeLayer(id); });
    if(map.getSource(src)) map.removeSource(src);

    // 선택된 것 중 해당 레벨 제거
    [...selection.keys()].forEach(k=>{ if(k.startsWith(lvl+'|')) selection.delete(k); });
    refreshSelectionSourceData();
    refreshSelectionFilter();
    setStatus(`${lvl} 레이어 제거됨`);
  }

  function firstSymbolId(){
    const layers = map.getStyle()?.layers || [];
    const sym = layers.find(l=>l.type==='symbol');
    return sym ? sym.id : undefined;
  }

  // ===== 기본 라벨 ON/OFF =====
  function toggleBaseLabels(show){
    if(!map || !detected) return;
    detected.baseLabelIds.forEach(id => tryLayout(id, 'visibility', show ? 'visible' : 'none'));
  }

  // ===== 우리 라벨 ON/OFF =====
  function applyOurLabelsVisibility(){
    const v = els.chkOurLabels.checked ? 1 : 0;
    ['sido-label','sigungu-label','emd-label'].forEach(id=>{ try{ map.setPaintProperty(id, 'text-opacity', v); }catch{} });
  }

  // ===== 런타임 색 적용 =====
  function applyRuntimeColors(){
    if(!map || !detected) return;
    const sea = els.waterColor.value, land=els.landColor.value, bcol=els.boundaryColor.value;
    const wOp = parseFloat(els.waterOpacity.value), lOp = parseFloat(els.landOpacity.value);
    const cW = parseFloat(els.countryWidth.value), aW = parseFloat(els.adminWidth.value);
    const cDashed = els.countryDashed.checked, aDashed = els.adminDashed.checked;

    // LAND
    if(detected.landBg.length){
      detected.landBg.forEach(id=>{ trySet(id,'background-color',land); trySet(id,'background-opacity', lOp); });
    }else{
      detected.landFill.forEach(id=>{ trySet(id,'fill-color',land); trySet(id,'fill-opacity', lOp); });
    }
    // WATER
    detected.water.forEach(id=>{
      const t = map.getLayer(id)?.type;
      if(t==='fill'){ trySet(id,'fill-color',sea); trySet(id,'fill-opacity',wOp); }
      else if(t==='line'){ trySet(id,'line-color',sea); trySet(id,'line-opacity',wOp); }
      else if(t==='background'){ trySet(id,'background-color',sea); trySet(id,'background-opacity',wOp); }
    });
    // 국가/경계(스타일 내부)
    detected.boundary.forEach(id=>{
      trySet(id,'line-color', bcol);
      trySet(id,'line-width', cW);
      trySet(id,'line-dasharray', cDashed ? [2,2] : [1,0]);
    });
    // 우리 행정 라인
    ['sido-line','sigungu-line','emd-line'].forEach(id=>{
      if(map.getLayer(id)){
        trySet(id,'line-color', bcol);
        trySet(id,'line-width', aW);
        trySet(id,'line-dasharray', aDashed ? [2,2] : [1,0]);
      }
    });
  }

  // ===== 선택(오버레이는 별도 소스/레이어로 관리; 대용량 안정적) =====
  function ensureSelectionSource(){
    if(!map.getSource('selection-src')){
      map.addSource('selection-src', { type:'geojson', data:{ type:'FeatureCollection', features:[] } });
    }
    selectionSourceInited = true;
  }
  function ensureSelectionLayer(){
    if(!map.getLayer('selection-overlay')){
      map.addLayer({
        id:'selection-overlay', type:'fill', source:'selection-src',
        paint:{ 'fill-color': els.selectColor.value, 'fill-opacity': els.selectHalf.checked ? 0.5 : 1.0 }
      }, firstSymbolId());
    }
  }
  function bindSelect(fillLayerId, lvl){
    if(!map.getLayer(fillLayerId)) return;
    // 중복 방지
    map._bindSel = map._bindSel || {};
    if(map._bindSel[fillLayerId]) return;
    map.on('click', fillLayerId, (e)=>{
      const feats = map.queryRenderedFeatures(e.point, { layers: [fillLayerId] });
      if(!feats.length) return;
      const f = feats[0];
      const name = f.properties?.[FIELDS[lvl]];
      if(!name) return;
      const key = `${lvl}|${name}`;
      if(selection.has(key)){ selection.delete(key); }
      else{ selection.set(key, JSON.parse(JSON.stringify(f))); }
      refreshSelectionSourceData();
      refreshSelectionFilter(); // 여기서는 전체 유지(우리는 오버레이는 자체 데이터라 필터 없이도 됨)
      setStatus(`선택 개수: ${selection.size}`);
    });
    map.on('mouseenter', fillLayerId, ()=> map.getCanvas().style.cursor='pointer');
    map.on('mouseleave', fillLayerId, ()=> map.getCanvas().style.cursor='');
    map._bindSel[fillLayerId] = true;
  }
  function refreshSelectionSourceData(){
    if(!selectionSourceInited) return;
    const feats = Array.from(selection.values()).map(ft=>{
      // 안전을 위해 속성만 간단 복사
      return { type:'Feature', geometry: ft.geometry, properties: ft.properties||{} };
    });
    const fc = { type:'FeatureCollection', features: feats };
    map.getSource('selection-src').setData(fc);
  }
  function refreshSelectionFilter(){
    // selection-src는 자체 데이터이므로 필터 불필요. (필터 사용 시 여기서 가능)
  }
  function updateSelectionStyle(){
    if(!map || !map.getLayer('selection-overlay')) return;
    map.setPaintProperty('selection-overlay','fill-color', els.selectColor.value);
    map.setPaintProperty('selection-overlay','fill-opacity', els.selectHalf.checked ? 0.5 : 1.0);
  }
  function clearSelection(){
    selection.clear();
    refreshSelectionSourceData();
    setStatus('선택 해제됨');
  }
  function exportSelectionGeoJSON(){
    const fc = map.getSource('selection-src')? map.getSource('selection-src')._data : {type:'FeatureCollection',features:[]};
    download('selection.geojson', JSON.stringify(fc,null,2), 'application/geo+json');
  }

  // ===== PNG 저장 =====
  function savePNG(){
    if(!map) return;
    const canvas = map.getCanvas();
    const data = canvas.toDataURL('image/png');
    fetch(data).then(r=>r.blob()).then(blob=>{
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='map.png'; a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    });
  }

  // ===== 시작 =====
  init();
})();
</script>
</body>
</html>
